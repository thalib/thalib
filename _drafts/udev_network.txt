Here is I am going to explain how to assign a ipaddress to NIC interface based on thier MAC address

This type of thing is need in the Embedded linux enviroment in places like switch/router/server designing
where you have N number of interfaces.


Now to change or assign the ip address may be simple as below

#ifconfig eth1 192.168.1.10 netmask 255.255.255.0 up

But in the embeded system we may connect a particulari interfcace to one network and we also need to assign the ip statically even if their name eth0 is changed to ethN. mostly this happens when we have a board with multiple PCI NIC - in such a case thier detection order may change or else one of the PCI NIC is removed. but the system script dosent know about it still it will assign ip to eth0



Notes:
================= 
[b16644@thalib ~]$ udevinfo -a -p /sys/class/net/eth1

http://liquidat.wordpress.com/2008/08/16/howto-find-matches-for-udev-rules/
http://ubuntuforums.org/showthread.php?t=168221
http://reactivated.net/writing_udev_rules.html#example-netif
http://fredericiana.com/2006/03/15/writing-udev-rules-short-notes/
http://lists.freedesktop.org/archives/devkit-devel/2009-April/000140.html
xmind.com

Normally we used to assign the ip address for a NIC like below

to get the info on interface

# ifconfig eth1 
eth1      Link encap:Ethernet  HWaddr 00:0F:FE:65:35:50  
          inet addr:172.29.38.95  Bcast:172.29.38.255  Mask:255.255.255.0
          inet6 addr: fe80::20f:feff:fe65:3550/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:309162 errors:0 dropped:0 overruns:0 frame:0
          TX packets:140241 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:322030834 (307.1 MiB)  TX bytes:19089697 (18.2 MiB)
          Memory:f0500000-f0520000 


Now to change or assign the ip address 
#ifconfig eth1 192.168.1.10 netmask 255.255.255.0 up

The above step is simple, but every time you have to do it manualy

But we can offload this task to system to automaticaly set it at every boot for us

Diffrent distros follow thier own method. 

For ubuntu/debian based distros

#emacs /etc/network/interfaces


auto eth0
iface eth0 inet static
        address 192.168.1.10
        netmask 255.255.255.0
        network 192.168.1.0
        broadcast 192.168.1.255
        gateway 192.168.1.1




Rules to rename the default eth interface to something eles, this rules is taken from Freescale P4080DS

SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@0", NAME="fm1-gb0"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@1", NAME="fm1-gb1"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@2", NAME="fm1-gb2"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@3", NAME="fm1-gb3"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@4", NAME="fm1-10g"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@5", NAME="fm2-gb0"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@6", NAME="fm2-gb1"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@7", NAME="fm2-gb2"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@8", NAME="fm2-gb3"
SUBSYSTEM=="net", DRIVERS=="fsl_dpa", ATTRS{devspec}=="/fsl,dpaa/ethernet@9", NAME="fm2-10g"

Speedup_udev
--------------------------------------------------------------

http://wiki.archlinux.org/index.php/Speedup_udev
Introduction

This article applies to stock Arch kernels.

The "Loading UDev uevents" takes up some time in the boot process. I was able to speed it up from 11.5 sec to 5.5 sec (udev-116).

The new udev-118 package does not only contain the new udev binairies, but also optimized scripts. (The hack will improve boottime, but only from 4sec to 3.5sec. (The script optimalisation is based on no blacklisted modules in rc.conf).


If you don't use MOD_AUTOLOAD="yes" this hack will have no effect.

If you rely on blacklisting certain modules, this hack is not for you. unless you're lucky and the /etc/modprobe.conf approach works.
Caution

This hack could corrupt the boot process and stop your pc from booting properly. If you have no idea what this hack is doing, i suggest you don't apply it.

USE IT AT YOUR OWN RISK
How it works

The /lib/udev/load-modules.sh script contains logic for blacklisting certain modules. This script is well written, but because this script runs for every module it slows down the boot process.
Option 1

If you replace the /lib/udev/load-modules.sh (create a backup first) with this:

#! /bin/sh
/sbin/modprobe $1

As you can see the script contains no blacklisting logic whatsoever, so it runs faster, but the rules in /etc/rc.conf don't work anymore. If you don't have any module blacklisted, you're done. (You will have to repeat this hack when you install a new version of udev)
Option 2

Its even faster if you skip the shell script and directly call modprobe.

replace all "/lib/udev/load-modules.sh" to "/sbin/modprobe" in /etc/udev/*.rules

sed -i "s#/lib/udev/load-modules.sh#/sbin/modprobe#g" /etc/udev/rules.d/*.rules

To revert to the old configuration, do:

sed -i "s#/sbin/modprobe#/lib/udev/load-modules.sh#g" /etc/udev/rules.d/*.rules

Option 3

Similar to Option 2, above, but just replace "/lib/udev/load-modules.sh" with a symlink to "/sbin/modprobe".
Blacklisting modules

Because the hack ignores the MODULES=() and MOD_BLACKLIST=() we need an other way to prevent modules from loading.

/etc/modprobe.conf can help. Add a line for every module you want blacklisted.

blacklist foo
blacklist bar

Beware this doesn't always work. As phrakture pointed out:

modprobe.conf blacklisting is not the same as the way we do it. It will actually not work at all.
Here's why:
modprobe's "blacklist" option blacklists modules loaded by that name and that name only. 

"modprobe foo" will not load foo. However, if some module "foo2" also depends on foo,
"modprobe foo2" will still load foo because blacklisting does not match dependent modules.

That's the whole reason we did blacklisting the way we did.

Sources

[debian wiki] : http://wiki.debian.org/udev
DeviceManagement under Debian/Linux : http://wiki.debian.org/DeviceManagement
http://reactivated.net/writing_udev_rules.html - Writing udev rules 
